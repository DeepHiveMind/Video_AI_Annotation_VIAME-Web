# High level design discussion.

I think I mostly understand what you've done here.  Because I'm trying to sift through >1000LoC, I want to discuss the high level concepts before engaging on a quest to review the code.

Before submitting this, I read over it and realized it has a more aggressive tone than I intended.  I think what you did here is great.  This is not a criticism, but an exploration of what the other options were and if there's something better we can do.

## Using it

Mostly behaves as intended, I think.

* How do I create only a head point, or only a tail point?
* There seem to be a lot of tricky situations I can get into, particularly after deleting a single feature point then re-entering edit mode to create another one.

![Screenshot from 2020-09-02 13-53-04](https://user-images.githubusercontent.com/4214172/92018853-b8e6e780-ed23-11ea-9a01-e595ab2cc096.png)

* It seems the line and polygon are independent, so the bounding box follows whatever the currently edited shape is.  You can end up with points outside the bounding box.

![Screenshot from 2020-09-02 13-46-47](https://user-images.githubusercontent.com/4214172/92018854-b97f7e00-ed23-11ea-8951-e25e7dc45479.png)

* The line's striped color I think is kind of unnecessary.  It doesn't really convey any meaning to me, I sort of feel like I'm supposed to know it means something special but I can't figure out what that is.

## Logic

Sorry in advance for the wall of text.

I've been thinking a long time about the enormous problem that something as simple as head/tail annotation poses to a codebase like viame web.  You take something as highly generic as what we've built so far, and you add head/tail, and you get something that, both from a UI standpoint and a software engineering standpoint, has now specialized itself for fish.  

The code for dealing with head/tail sunk its teeth into the core logic of nearly every critical bit of state management there is.  `useModeManager` is specialized for fish now.  `EditAnnotationLayer` specializes in fish.

This to me has been a nagging engineering problem since we began the project: how to support the ergonomics of domain data without sacrificing code sanity.

**Opinion**: EditAnnotaitonLayer should only concern itself with geometric primitives: Drawing lines, points, polygons, etc.  If it needs state for doing that, such as [creating new line, editing existing line], that's all well and good.  It should **not** be concerned with domain-specific shape compositions like this whole point-line-point thing we are calling headtail.  

I'm somewhat concerned that adding code that makes EditAnnotationLayer and useModeManager change behavior based on geoJSON properties metadata is a very slippery slope.

## A hypothetical

Suppose, in 3 weeks, we are asked to support a new type of erganomic semi-automatic annotation for starfish.  It's simple:

* place a point in the center.
* place between 1 and 5 spokes (with automatically populated connecting lines) on each visible leg(tentacle(arm?)?)? tip.

It's only incrementally more complex head/tail, but it's the exact same idea: automatic creation of implicitly linked geometry.

How would we support it?  More invasive surgery on useModeManager and EditAnnotaitonLayer?  I find the idea of having to modify core logic and possibly breaking big parts of the app to add what should be auxillary features rather unappealing.  

Where a feature lives in the code should be related to how important it is.

## options

We could punt.  Try something else later.   I think I'm currently somewhat opposed to this option, because the necessary course correction seems large to me.

We could also begin to think about what a more generic solution looks like.  I'm always hesitant to abstract too early, but in this case it would be for the sake of better modularity and not just "because we might need to support starfish later".

In other words, even if we never support starfish, a different way of organizing this may provide value

## A generic solution

What would a more generic solution look like?  What would we have to support?

The goal is sort of an elaborate dance between what the user does to the current state of annotations and what automatically (conditionally) happens in response.

* When you're doing this starfish annotation, there's higher-level state management going on than EditAnnotaitonLayer should care about.
* For example, if you're creating a point, some bit of code should know which starfish leg you're on.  EditAnnotationLayer should just know "we're creating a point -- wheeee"
* Something needs to listen to `update:geojson` and compare the mutation to its existing state, the potentially cause a new mutation on the geojson data AND state changes within useModeManager, such as 
